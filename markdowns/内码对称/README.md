---
tags:
  - 数据结构与算法:位运算
---

# 内码对称

```
时间限制: 1 Sec  内存限制: 128 MB
```

## 题目描述

C++中int型整数内码是一个32位的01序列，该01序列有些是对称的，有些是不对称的。对于给定的一个整数，在一些场合，需要判断其整数内码的对称性。这个事情要做好还非你不行呢。

## 输入

输入中含有一些整数n（0 ≤ n < 2^32）。

## 输出

统计其中一共有多少个其内码对称的整数，输出之。

## 样例输入

```
0
1
2147483649
2
3
```

## 样例输出

```
2
```

## 来源

作者未知。不过在浙江工业大学的在线oj上找到了一样的题目：[内码对称](http://cpp.zjut.edu.cn/ShowProblem.aspx?ShowID=1255)。

# 分析

这题最开始还以为对调高低位之后对比就行了，结果并不是，那样是高低位相同而不是对称【捂脸

然后解决方法就出来了，用位运算操作，对比高位和对称的低位是否相等就行了。  
需要注意的是读取的时候要赋值给无符号整数，因为位运算对于有符号位的数字会保留符号位。  
```cpp
for (int i = 0; i <= 15; ++i) {
    if ( ((n>>i) & 1) != ((n>>(31-i)) & 1) )
        break;
    if (i == 15) ++count;
}
```
其中`(n >> i) & 1`是取二进制从低位往高位数第`i`位的值，`31 - i`是对称位，`(n >> (31 - i)) & 1`是取对称位的值。

<br />

分析到此结束，下面是废话，不想浪费时间的可以[跳过](#具体实现)。

---

<br />

还记得这题，咱和某大佬在比代码可以写得多短 2333  
这个是他的代码（总计105个字符）：
```c
main(){int n,s=0,i;while(~scanf("%d",&n))for(i=0;i!=16&&!(n>>i&1^n>>31-i&1);++i&15||s++);printf("%d",s);}
```  
这个是我的代码（总计102个字符）：
```c
main(){int n,z=0,i;while(~scanf("%u",&n))for(i=31;i&&!(n>>i&1^n>>31-i&1);--i^15||++z);printf("%d",z);}
```  
> 这个代码没带头文件、main能不用返回值都是因为编译环境的问题，所以好孩纸们别学咱们这么浪【捂脸  
  读取输入的时候我们一般习惯是`scanf("%u", &n) != EOF`，查下`EOF`是宏定义，一般情况下都是`-1`，所以可以用`~scanf("%u",&n)`简写，但`EOF`的值具体要看解释器以及运行环境，好孩纸也别这么写【捂脸
  
然后判断条件从正常的`((n>>i)&1) != ((n>>(31-i))&1)`改成了丧病的`!(n>>i&1^n>>31-i&1)`，来解释下怎么改的。
首先根据[运算符的优先级](https://baike.baidu.com/pic/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7/4752611/0/63d9f2d3572c11df57c9a205612762d0f703c2f8?fr=lemma&ct=single#aid=0&pic=63d9f2d3572c11df57c9a205612762d0f703c2f8)，<br />
可知`>>`比`&`先执行，所以可以变成`(n>>i&1) != (n>>(31-i)&1)`，<br />
然后`-`比`>>`先执行，所以可以变成`(n>>i&1) != (n>>31-i&1)`，<br />
之后就很沮丧的发现`!=`比`&`先执行，两边的括号不能去掉，<br />
但是`^`的优先级比`&`低，而且`^`在这种情况下可以取代`==`，所以就用`!`和`^`取代掉`!=`，<br />
所以又可以去掉一个括号，最终变成了`!(n>>i&1^n>>31-i&1)`。

之后是循环的判断条件的解释：  
大致翻译下：  
`--i^15||++z`在这里等效于`i -= 1; if (i==15) ++z;`  
`++i&15||s++`在这里等效于`i += 1; if (i==16) s++;`  
为何可以这么做呢，
因为`||`运算符的性质，一旦前面的判断为`true`后面的就被短路了不会执行，只有在前面为`false`时才会执行后面的代码。根据c/cpp的规则，非0为true，0为false。  
然后位运算部分。根据异或运算的数学特性，两个一样的数进行**异或**运算结果是0，即`A XOR A == 0`。在`--i^15||++z`中，只有当`--i == 15`时才执行`++z`操作。  
在`++i&15||s++`中，`15`的二进制`1111`，在这里进行 按位与 运算意味着`i+1`后的值的二进制的最低4位为0时才执行`s++`操作。在这里i∈(0, 16]，只有当i为16时，最低4位才为0。

还有，可以看到虽然我的代码比他的短3个字符，但他的代码运算量比我的少一半，<br />
我的`for`循环在对称的时候从31执行到0，共32次；但他的从0到15，共16次，是我的一半。  
能仅仅比我多3个字符让运算量减少一半【给大佬递茶.gif

![给大佬递茶.gif]

以上。

# 具体实现

```cpp
#include <iostream>
using namespace std;

int main() {
//	freopen("in.txt","r",stdin);

	unsigned n, count = 0, i;
	while (cin >> n) {
		for (int i = 0; i <= 15; ++i) {
			if ( ((n>>i)&1) != ((n>>(31-i))&1) )
		    	break;
			if (i == 15) ++count;
		}
	}
	cout << count;

	return 0;
}
```


[给大佬递茶.gif]: ./给大佬递茶.gif
