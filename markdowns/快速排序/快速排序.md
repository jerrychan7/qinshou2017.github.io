{"tags": ["算法","排序","快速排序"]}

# 快速排序

快速排序（quick sort）是排序算法的一种，属于交换排序的一种，是对冒泡排序的一种改进。

## 流程

下面以从小到大排序为例。

首先，在数组内选择一个元素v，然后遍历一遍数组，把小于v的元素放在v左边，大于v的元素放在v右边。  
简单来说，将元素v作为中间值，或是说中轴，将数组分成左右两个子数组，左边数组内的元素全部小于v，右边的都大于v，两个子数组内的元素是无序的。

接下来，将对左右两个数组都可以执行上面的步骤，当子数组大小为1时结束，此时数组有序（每个元素的左边都小于自己，右边都大于自己，那该数组就是有序的）。

从算法流程可以看到算法可以用递归实现。

↓很抽象的示意图，左右两个子数组回到步骤1

```
+---+-------------+
| v |             | <-+
+---+-------------+   |
         ↓           |
+------+---+------+   |
|  <v  | v |  >v  |   |
+------+---+------+   |
    |          |      |
    +----------+------+
```

## 实现

```javascript
function quickSort(data, begin = 0, end = data.length - 1) {
    if (begin >= end) return;
    // 单次排序 将t作为选中的值 i和j向中间靠拢
    let i = begin, j = end, t = data[i];
    while (i < j) {
        // 从右往左 找到第一个小于t的值
        while (data[j] >= t && i < j) --j;
        // 将该值交换到左边i 然后i+1
        if (i < j) data[i++] = data[j];
        // 从左往右 找到第一个大于t的值
        while (data[i] <= t && i < j) ++i;
        // 将该值交换到右边j 然后j-1
        if (i < j) data[j--] = data[i];
    }
    // 当循环结束时 i=j 指向轴的位置
    let mid = i;
    data[mid] = t;
    // 递归
    quickSort(data, begin, mid - 1);
    quickSort(data, mid + 1, end);
}
```

详细的解释可以参考[nullzx](https://www.cnblogs.com/nullzx/p/5880191.html)的说明。

## 分析

如何取元素，理论上，当取的元素是刚好是数组的中位数时，可以有效减少递归次数，但寻找中位数需要排序，所以每次取中位数是不可能的。
而且从概率上来说，从数组中随机选择一个元素恰好是该数组的中位数的概率是一样的，所以一般图方便，都会直接选第一个或最后一个元素作为中间值。

因为在划分左右子数组时会乱交换元素，所以该排序算法是**不稳定**的。

$O(n^2)$，平均时间复杂度为$O(n\log_2n)$，空间复杂度为$O(\log_2n)$。


## 改进：三向切分

在伟大的前辈们的不懈努力下，快速排序还是给优化了。

上面也提到了，首先需要选出一个中间值作为轴，划分左右数组。当数组中有大量重复元素时，快速排序依旧会将单个值作为轴进行左右划分。
那如果，把和中间值相等的值都拢一块，作为一个有宽度的轴，那划分出来是子数组数量就会少很多，进行递归的次数就会大福下降。
简单来说，每次将数组分为三个子数组，左边数组内的元素全部小于v，右边的都大于v，中间的都等于v，左右两个子数组内的元素是无序的。

↓很抽象的示意图，左右两个子数组回到步骤1

```
+---+--------------+
| v |              | <-+
+---+--------------+   |
         ↓            |
+------+----+------+   |
|  <v  | =v |  >v  |   |
+------+----+------+   |
    |           |      |
    +-----------+------+
```

### 三向切分实现

```javascript
function quickSort3(data, begin = 0, end = data.length - 1) {
    if (begin >= end) return;
    // 单次排序 将t作为选中的值 i和j向中间靠拢
    let i = begin, t = data[i],
        k = i + 1, j = end;
    while (k <= j) {
        if (data[k] < t)
            data[i++] = data[k++];
        else if (data[k] > t) {
            let tmp = data[k];
            data[k] = data[j];
            data[j--] = tmp;
        }
        else ++k;
    }
    // 当循环结束时 k指向轴末端+1的位置 j指向轴末端 i指向轴开始
    data[i] = t;
    // 递归
    quickSort3(data, begin, i - 1);
    quickSort3(data, k, end);
}
```

示意图：

```
          +-+----------+
before    |v|          |
          +-+----------+
           ^begin     ^end
          +----+----+----------+----+
during    | <v | =v | unjudged | >v |
          +----+----+----------+----+
                ^->  ^->    <-^
                i    k        j
          +----+----+----+
after     | <v | =v | >v |
          +----+----+----+
                ^i ^j^k
```

## 改进：双轴快速排序

还有一个优化是取两个轴。根据两个轴，划分成三个数组，小于轴1的，在轴1和轴2之间的，和大于轴2的（轴1 < 轴2）。

直接示意图了，代码也懒得实现了，道理都和上面差不多，自己顿悟吧~~【才不是因为懒~~：

```
+----+-----------------------------------+
| v1 |                              | v2 | <-+
+----+-----------------------------------+   |
                    ↓                       |
+-------+----+--------------+----+-------+   |
|  <v1  | v1 | >=v1 && <=v2 | v2 |  >v2  |   |
+-------+----+--------------+----+-------+   |
    |               |                |       |
    +---------------+----------------+-------+
```
