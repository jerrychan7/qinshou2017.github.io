{"tags": ["数据结构与算法:树","团体程序设计天梯赛"]}

# 根据前中后遍历序列创建树

## 题目概述

这是道经典的树的题，根据前中后遍历序列创建树，分为三种情况：
1. 根据前中遍历序列创建树；
2. 根据中后遍历序列创建树；
3. 根据前后遍历序列创建树；

下面将展开对三种情况进行分析。

此外，还看到有特殊的通过“扩展先序遍历序列”构建树的，
扩展先序遍历是先对原有二叉树用空子树进行扩展，使每个节点都有左右子树存在，然后再对扩展后的二叉树进行先序遍历，遍历序列中使用特定的符号表示空子树。
如图下图所示的子树的扩展先序遍历序列为`ABC..D..E.FG...`，其中`.`表示扩展出来的空子树。

```
扩展前：            扩展后：
        A       |             A
      ,` `.     |          ,'   `.
     B     E    |        B         E
    / \     \   |     ,'   `.     /  \
   C   D     F  |    C       D  [.]   F
            /   |   / \     / \      / \
           G    | [.] [.] [.] [.]   G  [.]
                |                  / \
                |                [.] [.]
```
通过“扩展先序遍历序列”构建树比较特殊，在这里就偷懒不展开讲了，等哪天算法题有看到类似的咱再补上吧。

## 分析

前两种情况相似，所以我在这只详细讲根据第二种情况：根据中后遍历序列创建树。

首先，我们知道后序遍历是最后访问根节点的值的，所以后序遍历序列中的最后一个一定是根节点。一般采用先左后右的方式访问，所以后序遍历序列的组成结构是：  
**\[左子树的后序遍历序列\] + \[右子树的后序遍历序列\] + 根节点**，<br />
这种模式组成。

同理，**先**序遍历序列的第一个是根节点的值，组成模式是：  
**根节点 + \[左子树的先序遍历序列\] + \[右子树的先序遍历序列\]**。

其次，我们知道中序遍历是中间访问根节点的值的，所以中序遍历序列中根节点值的左右一定是左右子树的中序遍历序列。一般采用先左后右的方式访问，所以后序遍历序列的组成结构是：  
**\[左子树的中序遍历序列\] + 根节点 + \[右子树的中序遍历序列\]**，<br />
这种模式组成。

之后，我们可以依据根节点的位置将两个序列分割成左右子树的两个序列，直到无法再分割，子树就构建完成了。（同理知道 前中序遍历序列 也可以建树）

最后，根据这两个特性，可以看出，知道序列建树除了一定要知道根节点的信息外还要知道左右子树的下个序列构成，这就是为何知道 **前后遍历序列** 不能构建一棵树的原因，因为无法知道子序列，中序遍历序列是这三种序列中唯一一个根据根节点能分辨出左右子序列的序列。

接下来就一步一步手动建树来加深理解，假设现在给定：  
后序遍历序列 `2 3 1 5 7 6 4`，和  
中序遍历序列 `1 2 3 4 5 6 7`。

第一步，可以根据后序遍历序列知道根节点为`4`，根据中序遍历序列知道左右子树的中序遍历序列分别为`1 2 3`和`5 6 7`，
然后根据这两个子树的节点数量可以知道后序遍历序列的前3个是左子树的后序遍历序列，而后3个是右子树后序遍历序列。
```
中序遍历序列的情况:   后序遍历序列的情况:
       4                  4
      / \                / \
[1 2 3] [5 6 7]    [2 3 1] [5 7 6]
```
第二步，根据第一步的套路可以知道：左子树的根节点是`1`，左右子树的中序遍历序列分别为` `和`2 3`，后序遍历序列分别为` `和`2 3`；右子树的根节点是`6`，左右子树的中序遍历序列分别为`5`和`7`。
```
中序遍历序列的情况:   后序遍历序列的情况:
        4                    4
     ,'   `.              ,'   `.
    1       6            1       6
     \     / \            \     / \
    [2 3] 5   7          [2 3] 5   7
```
第三步，按套路来，3为根，2为左子树。至此树就构建完了。
```
        4     
     ,'   `.   
    1       6  
     \     / \ 
      3   5   7
     /
    2
```
很明显，上面的套路可以写成**递归**，你甚至可以边建树边输出树的前序遍历序列【滑稽  
以上。

## 具体栗子：[L2-006 树的遍历 （25 分）](https://pintia.cn/problem-sets/994805046380707840/problems/994805069361299456)
```
时间限制: 400 ms
内存限制: 64 MB
代码长度限制: 16 KB
```
给定一棵二叉树的后序遍历和中序遍历，请你输出其层序遍历的序列。这里假设键值都是互不相等的正整数。

### 输入格式：
输入第一行给出一个正整数N（≤ 30），是二叉树中结点的个数。第二行给出其后序遍历序列。第三行给出其中序遍历序列。数字间以空格分隔。

### 输出格式：
在一行中输出该树的层序遍历的序列。数字间以1个空格分隔，行首尾不得有多余空格。

### 输入样例：
```
7
2 3 1 5 7 6 4
1 2 3 4 5 6 7
```
### 输出样例：
```
4 1 6 3 5 7 2
```
### 来源
[团体程序设计天梯赛-练习集_L2-006. 树的遍历  
作者: 陈越  
单位: 浙江大学](https://pintia.cn/problem-sets/994805046380707840/problems/994805069361299456)

## 答案
```CPP
#include <iostream>
#include <queue>
using namespace std;
struct Node {
	int key;
	Node *left, *right;
};
/*
 *功能：根据中后序遍历序列和子节点总数构建树
 *参数：后序遍历序列，中序遍历序列，子节点总数
 *返回：根节点
 */
Node *build(int h[], int z[], int n) {
	if (!n) return NULL;
	Node *root = new Node;
	root->key = h[n-1];
	// 根节点在中序遍历序列中的下标 
	int mid = 0;
	while (mid < n)
		if (z[mid] == h[n-1]) break;
		else ++mid;
	// 递归建立左右子树 
	root->left = build(h, z, mid);
	root->right = build(h + mid, z + mid + 1, n - mid - 1);
	return root;
}
// 释放资源 
void del(Node *r) {
	if (!r) return;
	del(r->left); del(r->right);
	delete r;
}
int main() {
	int n, i; cin >> n;
	int hou[n], zhong[n];
	for(i = 0; i < n; ++i) cin >> hou[i];
	for(i = 0; i < n; ++i) cin >> zhong[i];
	Node *root = build(hou, zhong, n);
	// 层序遍历
	queue<Node*> que; que.push(root);
	bool b = true;
	while (!que.empty()) {
		Node *p = que.front(); que.pop();
		if (p->left) que.push(p->left);
		if (p->right) que.push(p->right);
		cout << (b? "": " ") << p->key;
		b = false;
	}
	del(root);
	return 0;
}
```
